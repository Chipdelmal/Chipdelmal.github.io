---
title: "Clustering Mosquito Movement"
tags: clustering optimization mosquito movement network community
article_header:
  type: overlay
  theme: dark
  background_image:
    gradient: 'linear-gradient(135deg, rgba(0, 0, 0 , .4), rgba(0, 0, 0, .4))'
    src: /media/mov/panel2.jpg
cover: /media/mov/panel.jpg
---

<br>

**Still being written. Sorry about the stubs and errors!**

<!--more-->

# Intro


# Description


<center><img width="100%" src="/media/mov/panel2.png"></center>

## Cleanup Pointsets and Kernels

The first step is to cleanup our data...

<center><img width="50%" src="/media/mov/matrix.png"></center>

## Detect Clusters

Now, we need to cluster our data in two ways: migration-based, and spatially. We will be using different frameworks for each, and...

### Network Communities
  
For the network community detection, we used the [cdlib](https://cdlib.readthedocs.io/en/latest/), which allows us to use a plaethora of algorithms such as [Girvan-Newmann](https://cdlib.readthedocs.io/en/latest/reference/cd_algorithms/algs/cdlib.algorithms.girvan_newman.html#cdlib.algorithms.girvan_newman), [Markov clustering](https://cdlib.readthedocs.io/en/latest/reference/cd_algorithms/algs/cdlib.algorithms.markov_clustering.html#cdlib.algorithms.markov_clustering), [eigenvector](https://cdlib.readthedocs.io/en/latest/reference/cd_algorithms/algs/cdlib.algorithms.eigenvector.html#cdlib.algorithms.eigenvector), [infomap](https://cdlib.readthedocs.io/en/latest/reference/cd_algorithms/algs/cdlib.algorithms.infomap.html#cdlib.algorithms.infomap), [spectral](https://cdlib.readthedocs.io/en/latest/reference/cd_algorithms/algs/cdlib.algorithms.r_spectral_clustering.html#cdlib.algorithms.r_spectral_clustering); amonst many others.

### Spatial Clusters

To do the spatial clustering, we decided to use [scikit-learn](https://scikit-learn.org/stable/index.html), several alternatives are available, such as [k-means](https://scikit-learn.org/stable/modules/clustering.html#k-means), [agglomerative](https://scikit-learn.org/stable/modules/clustering.html#hierarchical-clustering), [DBSCAN](https://scikit-learn.org/stable/modules/clustering.html#dbscan), and [spectral](https://scikit-learn.org/stable/modules/clustering.html#spectral-clustering) (amongst others).

## Clusters Alignment

Now, we would like to know how much do both algorithms overlap in their detections. Unfortunately, there is no way to know which cluster corresponds to which community between the two algoritms, so we needed to figure out a way to automatically "align" the output from both. 

The way we did this was with the use of a genetic algorithm. We encoded the problem with a list defined as:

```python
chromosome = [clustersIDs] + [communitiesIDs]
```

where the length of the chromosome is `2n` where `n` is the number of communities (or clusters). Every element of these lists maps one cluster to one community in the form:

```python
chromosome[1]   : ID of the first cluster identified
    ...
chromosome[n]   : ID of the last cluster identified
chromosome[n+1] : ID of the first community identified
    ...
chromosome[2n]  : ID of the last community identified
```

And where we can retrieve the indices of the nodes in the map that belong to each grouping by drawing them with their IDs from their detection dictionaries:

```python
clusters    = {1: nodesInClst_1, 2: nodesInClst_2, ..., n: nodesInClst_n}
communities = {1: nodesInComm_1, 2: nodesInComm_2, ..., n: nodesInComm_n}
```

The general idea behind the optimization routine is to order these lists in the way that maximizes the matches between the paired elements of the entries.

### Initialization

The way we initialize our chromosome populations is fairly straightforward, we simply generate shuffled versions of the lists of indices for clusters and communities, and assemble them together:

```python
chromosome = sample([1, 2, ..., n-1, n]) + sample([1, 2, ..., n-1, n])
```

### Mutation

The mutation operator is also quite straigtforward, we just have to do a [swap mutation](https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_mutation.htm) operation with the caveat that we must do each one of the sections of our chromosome independently (no inter-zone mutation allowed).


```python
chromosome = [ 1,  2, ...,  n-1,  n| n+1, n+2, ..., 2n-1, 2n]
             |---- swap within ----|----  swap within ------|
```

### Crossover

Same thing applies with our crossover operator, we are using an [OX1 crossover](https://www.tutorialspoint.com/genetic_algorithms/genetic_algorithms_crossover.htm) function to each part of our chromosomes:

```python
chromosomeA = [1, 2, ..., n-1, n | n+1, n+2, ..., 2n-1, 2n]
chromosomeB = [1, 2, ..., n-1, n | n+1, n+2, ..., 2n-1, 2n]

offspring = OX1(chromosomeA[1:n], chromosomeB[1:n]) + OX1(chromosomeA[n:2n], chromosomeB[n:2n])
```

### Fitness

Now, to calculate the fitness of our solution, or how close are we to find a good alignment between the clusters and communities, we take each pairwise mapping of indices, then retrieve the set of nodes contained in the structures' indices, and calculate the size of the intersection between the two sets:

```python
alignment[i] = len(clusters[chromosome[i]] âˆ© clusters[chromosome[n+i]])
```

We repeat the same process for all the pairwise elements of the list and add them all together:

```python
fitness = sum(alignment)
```

## Visualize


<center><img width="100%" src="/media/mov/panel.png"></center>


# Code Repo

* Repository: [Github Repo](https://github.com/dd-harp/mosquitoNetworks)
* Dependencies: [deap](https://deap.readthedocs.io/en/master/), [scikit-learn](https://scikit-learn.org/stable/index.html), [cdlib](https://cdlib.readthedocs.io/en/latest/index.html)


<!-- https://chipdelmal.github.io/MGDrivE_Presentations/IHME2021/#/1/8 -->