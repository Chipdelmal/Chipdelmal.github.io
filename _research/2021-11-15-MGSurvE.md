---
title: "MGSurvE"
tags: network crispr mosquito surveillance optimization python
article_header:
  type: overlay
  theme: dark
  background_image:
    gradient: 'linear-gradient(135deg, rgba(0, 0, 0 , .4), rgba(0, 0, 0, .4))'
    src: /media/mgsurve/mgsurve_diagram.jpg
cover: /media/mgsurve/mgsurve_diagram.jpg
---

<br>

[MGSurvE](https://github.com/Chipdelmal/MGSurvE) (MGSurvE: Mosquito Gene SurveillancE) is a software package created to optimize the distribution of mosquito traps in complex heterogeneous landscapes.

<!--more-->

# Model Description


## Migration Matrix

As it was the case for [MGDrivE](2017-07-01-MGDrivE.html), the movement of mosquitos is modelled as a network of connected sites. 

For most cases, calculating the migration probability between sites is calculated with a kernel that is a function of the distance between sites $$\kappa$$, and some biological parameters $$\rho$$.
This time, however, there is an additional masking parameter $$\lambda$$ that varies depending on the probability of the individual moving from the point type of the source to the destination site.

$$\alpha(s_i\to s_j)= \kappa(D(s_i\to s_j), \rho_{bio}) * \lambda(\hat{s}_i, \hat{s}_j)$$	

Repeating this process for each point pair, and normalizing the resulting matrix gives us our migration matrix $$\tau$$:

$$
  \overline{\overline{\tau_{[s_n,s_n]}}} = 
    \begin{Vmatrix}
      \alpha({s_1\to s_1}) & \alpha({s_1\to s_2}) & ... & \alpha({s_1\to s_{n-1}}) & \alpha({s_1\to s_n}) \\
      \alpha({s_2\to s_1}) & \alpha({s_2\to s_2}) & ... & \alpha({s_2\to s_{n-1}}) & \alpha({s_2\to s_n}) \\
      \vdots  &  & \ddots  &  & \vdots  \\
      \alpha({s_{n-1}\to s_1}) & \alpha({s_{n-1}\to s_2}) & ... & \alpha({s_{n-1}\to s_{n-1}}) & \alpha({s_{n-1}\to s_n}) \\
      \alpha({s_n\to s_1}) & \alpha({s_n\to s_2}) & ... & \alpha({s_n\to s_{n-1}}) & \alpha({s_n\to s_n})
    \end{Vmatrix}
$$	

## Migration With Traps

Now, to add traps into the migration equations, we calculate the probability of a mosquito falling into a trap with a trap attractiveness kernel $$\eta$$; but this time, as mosquitos can't escape the traps, and must remain in the same trap for the rest of the simulation, we have three different sections of the matrix:

$$
  \begin{align*} 
    \delta(s_i\to t_j) &= \hat{\eta}(D(s_i\to t_j), \hat{\rho}_{trap}) * \phi(\hat{s_i}, \hat{t_j})  &\Rightarrow \overline{\overline{\alpha_{[s_n,t_n]}}} & & \text{Distance-based trapping efficacy}\\
    \delta(t_i\to s_j || t_i\to t_j |_{i\neq j}) &= 0 &\Rightarrow \overline{\overline{0_{[t_n,s_n]}}}& & \text{No migration out of the traps}\\
    \delta(t_i\to t_i) &= 1  &\Rightarrow  \overline{\overline{I_{[t_n,t_n]}}}& & \text{Stay traped!}
  \end{align*}
$$

To put these new sections together with the original migration matrix $$\tau$$, we assemble the following block matrix $$\chi$$:

$$
    \overline{\overline{\chi_{[s_n+t_n, s_n+t_n]}}} =
      \begin{Vmatrix}
        \overline{\overline{\tau_{[s_n,s_n]}}}  &  \overline{\overline{\alpha_{[s_n,t_n]}}}  \\
        \overline{\overline{0_{[t_n,s_n]}}}     &  \overline{\overline{I_{[t_n,t_n]}}}
                    \end{Vmatrix} =
        \begin{bmatrix}
          \overline{\overline{B}}  &  \overline{\overline{A}} \\
          \overline{\overline{0}}  &  \overline{\overline{I}}
        \end{bmatrix}
$$


##  Fitness Function

For the optimization function to work, we need a fitness function (or cost function). In the gene drive context, we'd like to minimize the time it takes for detection of an undesired transgene. To calculate this, I decided to use the [Markov fundamental matrix](https://math.libretexts.org/Bookshelves/Applied_Mathematics/Applied_Finite_Mathematics_(Sekhon_and_Bloom)/10%3A_Markov_Chains/10.04%3A_Absorbing_Markov_Chains):

$$\overline{\overline{F_{[s_n,s_n]}}}=(I-B)^{-1}$$

which gives us the number of timesteps it takes for a mosquito to fall into a trap from any initial point in the landscape. Now, to summarize this information into a metric, we can calculate the average maximum time from each one of these sites:

$$
  \begin{align*} 
                    \overline{\varphi_{[s_n]}} &=Max^{j}(\overline{\overline{F(i, j)}})\\
                    \phi &= Mean(\overline{\varphi_{[s_n]}})
  \end{align*} 
$$

Although other combinations could be used too (average of averages, medians, etcetera).


<center><img src="/media/mgsurve/STP_10_TRP.jpg" style="width:75%;"></center>



# Code and Availability

Most of the package revolves around a [landscape](https://chipdelmal.github.io/MGSurvE/build/html/MGSurvE.html#MGSurvE.landscape.Landscape) object exchanging information with the [DEAP](https://deap.readthedocs.io/en/master/) package. We are providing interfaces to do the calculations or provide overriding values (or functions) with [demos](https://chipdelmal.github.io/MGSurvE/build/html/landscapeCreation.html) and thorough [documentation](https://chipdelmal.github.io/MGSurvE/build/html/index.html).


<center><img src="https://chipdelmal.github.io/MGSurvE/build/html/_images/demo_updatedLandscape.jpg" style="width:60%;"></center>

[MGSurvE](https://github.com/Chipdelmal/MGSurvE) can be installed in its current development state from [pypi](https://pypi.org/project/MGSurvE/):

```bash
pip install MGSurvE
``` 


# Youtube Playlist

<center><iframe width="560" height="315" src="https://www.youtube.com/embed/videoseries?list=PLRzY6w7pvIWrOSwOlu_MXbOr14wx9xuwT" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></center>


